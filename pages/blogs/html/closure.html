<!DOCTYPE html>
<html>
<head>
<title>closure</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<h2>作用域</h2>
<ul>
<li>作用域：根据名称查找变量的一套规则。</li>
<li>编译的三个阶段：<br />
1. 词法分析：将字符组成的字符串分解成有意义的代码块，这些代码块被称为词法单元（token）。<br />
2. 语法分析：将词法单元流数组，转换成一个由元素逐级嵌套组成的“抽象语法树”（AST）。<br />
3. 代码生成：将AST转换为可执行的代码（机器指令）。 <br />
JS引擎在2和3阶段都会进行性能优化，大部分情况下编译发生在代码执行前的几微妙。  
</li>
<li>变量的赋值：1）编译器在当前作用域中声明一个变量；2）运行时引擎会在作用域中查找该变量，然后赋值；  
</li>
<li><strong>LHS查询：</strong>当需要赋值的时候，去查找赋值的目标（变量是否声明）  
</li>
<li><strong>RHS查询</strong>：当需要获取变量的值时，去查找其源头（根据变量容器取变量值）  
</li>
<li>遍历嵌套作用域链的规则：从当前作用域开始，向上一级层层查找，直到最外层的全局作用域。  
</li>
<li>RHS引用找不到变量，会抛出ReferenceError异常；RHS引用找到变量后对变量进行不合理操作，会抛出TypeError异常；LHS引用不成功会导致隐式创建全局变量（非严格模式）  
</li>
<li>JS只有词法作用域，即书写代码时各自的位置决定；但是this表现得像动态作用域；  
</li>
<li>欺骗词法作用域：eval()和with，导致JS引擎无法在编译时优化，性能下降，最好不用。  
</li>
<li>我理解的JS作用域：全局作用域，函数作用域，ES6中新增let和const块作用域；函数作用域（软件设计中，最小限度暴露必要内容，访问权限，规避命名冲突）  
</li>
<li>回调参数中的匿名函数表达式  
</li>
<li>立即执行函数表达式</li>
<li>let块作用域中的声明不会提升</li>
<li>特殊：try/catch中catch分句会创建一个块作用域，with块作用域</li>
</ul>
<h2>提升</h2>
<ul>
<li>提升：所有的声明（变量和函数）都会被“移动”到各自作用域的最顶端</li>
<li>声明会被提升，赋值和其他运行逻辑会留在原地</li>
<li><code>var a = 2;</code> 时，JS会将其看成<code>var a;</code>和<code>a = 2;</code> 第一个会在编译阶段进行提升，第二个赋值声明会被留在原地等待执行。</li>
<li>每个作用域都会进行提升操作</li>
<li>函数声明会被提升，但函数表达式不会被提升</li>
<li>函数声明先被提升，然后才是变量声明提升</li>
<li>后面的函数声明会覆盖前面的函数声明</li>
</ul>
<h2>闭包</h2>
<ul>
<li>通俗理解：<br />
1）在函数A内部定义一个函数B，函数B作用域链包含了函数A作用域，函数B可以记住其所在的此法作用域，不会被垃圾回收（创建闭包）；<br />
2）函数B在本身词法作用域外执行，即访问1）中记住的词法作用域（使用闭包）；  
</li>
<li>缺点：由于闭包作用域不会被垃圾回收，内存占用。</li>
<li>优点：可以保留外部作用域对一个变量的私有引用；设计私有的方法和变量；避免全局变量的污染；</li>
<li>实例：<br />
1）闭包函数作为函数参数传递给setTimeout() </li>
</ul>
<pre>
function wait(message) {
	 setTimeout( function timer(){
		 console.log( message );
	 }, 1000 );
 }
 wait( "Hello, closure!" );
</pre> 
<p>2）在定时器、事件监听器、Ajax请求、跨窗口通信中，只要使用了回调函数，实际上就是在使用闭包。</p>
<pre>
function setupBot(name,selector) {
	$( selector ).click( function activator(){
		console.log( "Activating: " + name );
	} );
}
setupBot( "Closure Bot 1", "#bot_1" );
setupBot( "Closure Bot 2", "#bot_2" );
</pre>
<ul>
<li><strong>经典例子</strong><br />
1）  
</li>
</ul>
<pre>
for (var i=1; i<=5; i++) {
	setTimeout( function timer(){
		console.log( i );
	}, i*1000 );
}
</pre>
<p>输出是每秒一次的频率输出6,6,6,6,6
i*1000是每次都会计算，即1000，2000，3000，4000，5000
我的理解：setTimeout()为异步方式，所以for循环会在很短的时间内执行完5次循环，第一次执行setTimeout(func,1000)，将会设定一个1秒的定时器，1秒之后会将func函数加入到事件队列中；第二次执行setTimeout(func,2000)，将会设定一个2秒的定时器，2秒之后会将func函数加入到事件队列中；这样输出的频率为1秒。由于for循环为同步方式，所以事件队列会等同步事件执行完再执行。而当事件队列中执行console.log(i)时，当前i会访问外层作用域，即for循环中i的值，即为6。
备注：如果setTimeout()函数中，i*1000改为0，则结果为同时输出6,6,6,6,6
问题：这里只有一个闭包作用域，如果要打印出1，2，3，4，5得要这5个延迟函数，分别引用不同的i，也就是不同的作用域。所以需要创建不同的作用域。  
</p>
<p><strong>改写方式1</strong>：立即执行函数能创建作用域</p>
<pre>
for (var i=1; i<=5; i++) {
	(function(){
		var j = i;
		setTimeout( function timer(){
			console.log( j );
		}, j*1000 );
	})();
}
</pre>
<p>或者</p>
<pre>
for (var i=1; i<=5; i++) {
	(function(j){
		setTimeout( function timer(){
			console.log( j );
		}, j*1000 );
	})( i );
}
</pre>
<p>输出：每秒一次的频率输出0,1,2,3,4,5<br />
<strong>改写方式2</strong>：let可劫持块作用域  
</p>
<pre>
for (var i=1; i<=5; i++) {
	let j = i; // 闭包的块作用域
	setTimeout( function timer(){
		console.log( j );
	}, j*1000 );
}
</pre>
<p>或者：for(let=i; ;)每次迭代都会产生新的let块作用域</p>
<pre>
for (let i=1; i<=5; i++) {
	setTimeout( function timer(){
		console.log( i );
	}, i*1000 );
}
</pre>
<p>输出：每秒一次的频率输出0,1,2,3,4,5<br />
相关链接： <br />
<a href="http://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&amp;mid=2651552304&amp;idx=2&amp;sn=6abd16cf650f64cdcc12abfbb6231cbc&amp;chksm=8025adf1b75224e789d21d12750949d3d4e9428b7f5add79aab6945c7d98cf1549da17a2b337&amp;mpshare=1&amp;scene=23&amp;srcid=0729WeoziBvRKNSgKvHuBd9a#rd">闭包面试题</a>   
</p>
<p><strong>相关知识</strong>： <br />
1.普通函数：   
</p>
<pre>
function compare(value1,value2){
	if(value1 < value2){
		return -1;
	}else if(value1 > value2){
		return 1;
	}else{
		return 0;
	}
}
var result = compare(5,10);
</pre>
<p><img src="http://upload-images.jianshu.io/upload_images/7008018-e2bf0b3e455a59de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="函数执行时的作用域链" /> <br />
解释：在创建/声明compare()函数时，会创建一个预先包含全局变量对象的作用域链；当执行函数/函数被调用时，会创建一个执行环境及相应的作用域链，并且创建本地活动对象，并将其推入作用链前端；当compare()函数执行完毕后，执行环境的作用域链被销毁，compare()的活动对象已没用（标记清除或引用计数），最后被垃圾回收。<br />
2.闭包函数   
</p>
<pre>
function createComparisonFunction(propertyName){
	return function(object1,object2){
		var value1 = object1[propertyName];
		var value2 = object2[propertyName];
		if(value1 < value2){
			return -1;
		}else if(value1 > value2){
			return 1;
		}else{
			return 0;
		}
	};
}
var compareNames = createComparisonFunction("name");
var result = compareNames({name:"Nicholas"},{name:"Greg"});
compareNames = null; // 解除引用
</pre>
<p><img src="http://upload-images.jianshu.io/upload_images/7008018-0eb9b6b8c5728346.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="闭包函数执行时的作用域链" /><br />
解释：当createComparisonFunction()函数执行完毕后，其执行环境的作用链被销毁，但是其活动对象依然被保留在内存中，还存在引用。直到匿名函数被销毁后，createComparisonFunction()的活动对象才会被销毁。  
</p>
<h2>模块</h2>
<ul>
<li>模块函数内：声明私有变量和内部函数；内部函数可访问私有变量；返回对象，其属性为内部函数。</li>
</ul>
<pre>
function CoolModule() {
	var something = "cool";
	var another = [1, 2, 3];

	function doSomething() {
		console.log( something );
	}

	function doAnother() {
		console.log( another.join( " ! " ) );
	}

	return {
		doSomething: doSomething,
		doAnother: doAnother
	};
}
var foo = CoolModule();
foo.doSomething(); // cool
foo.doAnother(); // 1 ! 2 ! 3
</pre>
<p>备注：模块函数也可直接返回内部函数，例如jQuery中的$标识符就是jQuery模块的公共API。   
</p>
<ul>
<li><strong>单例模式</strong><br />
当只需要一个实例时  
</li>
</ul>
<pre>
var foo = (function CoolModule() {
	var something = "cool";
	var another = [1, 2, 3];

	function doSomething() {
		console.log( something );
	}

	function doAnother() {
		console.log( another.join( " ! " ) );
	}

	return {
		doSomething: doSomething,
		doAnother: doAnother
	};
})();

foo.doSomething(); // cool
foo.doAnother(); // 1 ! 2 ! 3
</pre>
<p>备注：将模块函数，改为立即执行函数。</p>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
